# 计算机网络

## TCP
最常见的TCP三次握手、四次挥手不多说了，基础中的基础。
### 为什么TCP是三次握手才能确立连接？
这个问题可以有两种角度来回答 
1. TCP只有确立了双方的接收发送能力才能连接。
2. 还有一种在下面讨论一下

TCP中的连接指的是：用于保证可靠性和流控制机制的信息，包括Socket、序列号以及窗口大小叫做连接。

也就是说，建立一个TCP连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对Socket是有互联网地址标识符和端口组成的；窗口大小主要用来做流控制；最后的序列号是用来追踪 发起方 发送的数据包序号，接收方 可以通过序列号向 发送方 确认某个数据包的成功接收。

主要是有三个原因：
- 通过三次握手才能阻止重复历史连接的初始化
- 通过三次握手才能对通信双方的初始序列号进行初始化
- 讨论其他次数握手建立连接的可能性

#### 历史连接
为了阻止历史的重复连接初始化造成的混乱问题，防止使用TCP协议通信的双方建立了错误的连接。

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210109145106.png)

有一个场景：如果通信双方的次数只有两次，那么发送方一旦发出建立连接的请求之后就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果TCP建立连接只能通信两次，难么接收方只能选择接受或者拒绝发送方发起的请求，因为接收方并不清楚这一次请求是不是由于网络拥堵而早早过期的连接
。

所以TCP使用三次握手来建立连接并在连接引入了RST这一标志位，接收方收到请求时会将发送方发来的SEQ+1发送给对方，这时由发送方来判断当前连接是否是历史连接：
- 如果是历史连接，也就是SEQ过期或者超市，则会发送RST终止。
- 如果不是，则会发送ACK建立连接。

使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。
#### 初始化序列号
另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：

- 数据包被发送方多次发送造成数据的重复；
- 数据包在传输的过程中被路由或者其他节点丢失；
- 数据包到达接收方可能无法按照发送顺序；

为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：

- 接收方可以通过序列号对重复的数据包进行去重；
- 发送方会在对应数据包未被 ACK 时进行重复发送；
- 接收方可以根据数据包的序列号对它们进行重新排序；

序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。
#### 为什么不是两次四次或者更多次？
- 为什么不是两次？
    两次不能确保双方的接收发送能力

- 为什么不是四次或更多次？
    因为三次已经够了，再多也不能优化反而会增加负担，这个问题也够傻了。
### 为什么TCP是四次挥手才能断开连接？

### TCP怎么保证可靠传输
1.  应用数据被分割成TCP认为最适合发送的数据块
2.  TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层
3.  校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4.  TCP的接收端会丢弃重复的数据
5.  流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
6.  拥塞控制：当网络拥塞时，减少数据的发送。
7.  ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8.  超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### TCP的ARQ协议
自动重传请求（Automatic Repeat-reQuest,ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送一段时间之内没有收到确认帧，他通常回重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。
#### 停止等待ARQ
- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到ACK确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

优点：简单
缺点：信道利用率低，等待时间长。
1.  无差错情况：
发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。
2.  出现差错情况（超时重传）：
停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过得分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种字段重传方式常称为自动重传ARQ。另外在停止等待协议中如果收到重复分组，就丢弃该分组，但同时还要发送确认。
3.  确认丢失和确认迟到
    -   确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送一个M1确认消息，但却在传输过程中丢失，而A不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1.丢弃这个重复的M1消息，不向上层交付。2.向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）
    -   确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了两份确认消息）。处理如下：1.A收到重复的确认后，直接丢弃。2.B收到重复的M1后，也直接丢弃重复的M1。
#### 连续ARQ
连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

优点：信道利用率高，容易实现，即使确认丢失，也不必重传。
缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。比如：发送方发送了5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫Go-Back-N（回退N），表示需要退回来重传已经发送过的N个消息。

### TCP的拥塞控制
在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不会过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口设为拥塞窗口和接收方的接收窗口中较小的一个。

TCP的拥塞窗口采用了四种算法：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。

- 慢开始：慢开始算法的思路就是当主机开始发送数据时，如果立即把大量数据字节注入到网络中，那么可能会引起网络阻塞，因为现在不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- 拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即没经过一个往返时间RTT就把发送方的cwnd+1
- 快重传和快恢复：在TCP/IP中，快重传和快恢复（FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，他会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，
### TCP中的滑动窗口和流量控制
TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方的发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口的大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。

## UDP
这里主要是介绍TCP和UDP的区别
![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210126145615.jpg)

UDP在传输数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通讯），比如：QQ语音，QQ视频，直播等等。

TCO提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），但TCP难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。

## 浏览器输入url并回车的过程以及相关协议
1.  根据域名查询域名的IP地址，DNS解析。
2.  TCP连接
3.  发送HTTP请求
4.  服务器处理请求并返回HTTP报文
5.  浏览器渲染
6.  连接结束


## HTTP协议

### HTTP1

HTTP请求格式
![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210126172729.jpg)

HTTP响应格式
![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210126173020.jpg)

状态码:
// TODO 
请求头：
// TODO
### HTTP2
l
### HTTPS
浏览器使用HTTPS的URL访问服务器，建立SSL连接
在整个过程中，产生了两对非对称密钥、一个对称密钥。服务端一对非对称加密的密钥：公钥A，私钥B。证书机构一对非对称加密的密钥：公钥C，密钥D。客户端产生一个对称密钥E。
1.  服务器发送非对称加密的公钥A给浏览器
2.  客户端（SSL/TLS）解析证书
3.  生成随机值，作为对称加密的密钥E
4.  浏览器使用服务器返回的公钥A，对自己生成的对称加密秘钥E进行加密，得到密钥AE
5.  浏览器将密钥AE发送给服务器
6.  服务器使用自己的私钥B对接收的密钥AE进行解密，得到对称加密密钥E
7.  将信息和密钥E混合在一起进行对称加密
8.  将加密的内容发送给客户端
9.  客户端用密钥E解密信息

整个过程中，为了保证对称密钥E的安全，使用了服务端的非对称公钥A进行加密，只有非对称私钥B才能解出E。为了保证服务端公钥A传送给正确的一方，就需要用证书来验证。证书的目的就是为了让对方相信这个数据是我放松的，而不是其他人发送的。
### 区别
#### HTTP1.0和HTTP1.1的区别
1.  HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。而HTTP1.0不支持长连接。客户端和服务器没进行一次HTTP操作，就建立一次连接。
2.  缓存处理
3.  Host头处理：1.0请求的url并没有传递主机名（服务器与IP地址绑定）1.1请求和响应都支持Host头域（虚拟主机共享IP地址）
4.  1.1新增错误状态码
5.  带宽优化以及网络连接的使用：1.1允许只请求资源的某个部分
#### HTTP2和HTTP1.X的区别
1.  新的二进制格式
2.  多路复用
3.  header压缩
4.  服务端推送
#### HTTPS和HTTP的区别
1.  HTTPS协议需要到CA申请证书
2.  HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS（运行在TCP之上）之上，内容加密。
3.  连接端口不一样，HTTP是80，HTTPS是443
4.  HTTP连接简单，没有状态。HTTPS是SSL加密的传输，身份认证的网络协议，更安全。
## 其他协议

### DNS
#### 1、DNS域名结构
域名的层次结构
域名的分级
#### 2、域名服务器
|分类|作用|
|-|-|
|根域名服务器|最高层次的服务器，本地域名服务器解析不了的域名就会向其求助|
|顶级域名服务器|负责管理在该顶级域名服务器下注册的二级域名|
|权限域名服务器|负责一个区的域名解析工作|
|本地域名服务器|当一个主机发出DNS查询请求时，这个查询请求首先发给本地域名服务器|
#### 3、域名解析过程
1.  主机先向本地域名服务器进行递归查询
2.  本地域名服务器采用迭代查询，向下一个根域名进行查询。
3.  根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址
4.  本地域名服务器向顶级域名服务器进行查询
5.  顶级域名服务器告诉本地域名服务器，下一步查询权限域名服务器的IP地址
6.  本地域名服务器向权限域名服务器进行查询
7.  权限域名服务器告诉本地域名服务器所查询的主机的IP地址
8.  本地域名服务器最后把查询结果告诉主机
### ARP
