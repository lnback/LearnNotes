# CSAPP笔记
## 一、计算机系统漫游
### 1.1 信息就是位+上下文
```c
#include <stdio.h>

int main(){
    printf("hello world!\n");
    return 0
}
```

`hello`程序的生命周期就是从一个源程序（源文件）开始的。源程序实际上就是一个由0和1组成的位（比特）序列，8位组成一个字节。

大部分的现代计算机系统都使用ASCII标准来表示文本字符，也就是用一个唯一的单字节大小的整数值来表示每个字符。

像hello.c这样只由ASCII字符构成的文件成为文本文件，其他的文件都称为二进制文件。

系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。
### 1.2 程序被其他程序翻译成不同的格式
为了能够在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为**可执行目标**的格式打包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标程序**。

在UNIX系统中执行
```cmd
gcc -o hello hello.c
```
GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。翻译过程分为四个阶段：预处理、编译、汇编、链接。

- 预处理阶段。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如`hello.c`中第一行的`#include<stdio.h>`命令告诉预处理器读取系统头文件`stdio.h`的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以`.i`作为文件扩展名
- 编译阶段。编译器（cc1）将文本文件`hello.i`翻译成文本文件`hello.s`，它包含一个汇编语言程序。
```
main:
    subq    $8, %rsp
    movl    $.LCO, %edi
    call    puts
    movl    $0, %eax
    addq    $8, %rsp
    ret
```
- 汇编阶段。汇编器（as）将`hello.s`翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件`hello.o`中。`hello.o`文件是一个二进制文件。
- 链接阶段。因为hello程序调用了`printf`函数，它是每个C编译器都提供的标准C库中的一个函数。`printf`函数存在一个名为`printf.o`的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的`hello.o`程序中。链接器（ld）就负责处理这种合并。结果就得到了`hello`文件，它是一个可执行文件。可以被加载到内存中，由系统执行。


### 1.3 了解编译系统的益处
- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。


### 1.4 处理器读并解释储存在内存中的指令

## 二、