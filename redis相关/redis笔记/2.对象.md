[toc]
# 对象
## 引言
前一章介绍了Redis的主要数据结构，但Redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统 ，这个系统包含**字符串对象、列表对象、哈希对象、集合对象和有序集合对象**这五种类型的对象。

使用对象有两个好处：

- 执行命令前，根据对象类型来判断是否可以执行此命令。
- 针对不同使用场景，为对象设置多种不同的数据结构实现，达到优化的目的。

此外，对象系统还引入了**引用计数实现内存回收机制，以及对象共享。**
## 一、对象的类型和编码
Redis中的每一个键值对的键和值都是一个对象，每个对象都由一个``redisObject``结构表示，该结构中和保存数据有关的三个属性分别是``type``属性、``encoding``属性和``ptr``属性。
```c
typedef struct redisObject{
    // 类型
    unsigned typed : 4;
    // 编码
    unsigned encoding :4;
    //指向底层实现数据结构的指针
    void * ptr;

}obj;
```
结构体的冒号表示位域，表示该变量占用的二进制位数。
### 1.1 对象的类型

对象的``type``属性记录了对象的类型，属性的值如下表所示：
|类型常量|对象的名称|
|:-:|:-:|
|REDIS_STRING|字符串对象|
|REDIS_LIST|列表对象|
|REDIS_HASH|哈希对象|
|REDIS_SET|集合对象|
|REDIS_ZSET|有序集合对象|
对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值可以是上表中的其中一个
所以，当我们称呼一个数据库键位“字符串键”时，我们指的是“这个**数据库键**所**对应的值为字符串对象**”；同理，当我们称呼一个键位“列表键” 时，我们指的是“这个 **数据库键** 所 **对应的值为列表对象**”

### 1.2 对象的编码
对象的``ptr``指针指向对象的底层实现数据结构，而这些数据结构由对象的``encoding``属性决定。``encoding``属性如下表所示：
|编码常量|编码所对应的底层数据结构|
|:-:|:-:|
|REDIS_ENCODING_INT|``long``类型的整数|
|REDIS_ENCODING_EMBSTR|``embstr``编码的简单动态字符串|
|REDIS_ENCODING_RAW|简单动态字符串|
|REDIS_ENCODING_HT|字典|
|REDIS_ENCODING_LINKEDLIST|双端链表|
|REDIS_ENCODING_ZIPLIST|压缩列表|
|REDIS_ENCODING_INTSET|整数集合|
|REDIS_ENCODING_ZSKIPLIST|跳跃表和字典|

---

## 二、字符串对象

### 2.1 编码方式
字符串对象的编码可以是``int``、``raw``或者``embstr``。
- 如果一个字符串对象保存的是整数值，并且这个整数值可以用``long``类型来表示，那么字符串对象会将整数值保存在字符串对象结构的``ptr``属性里面(将``void*``转换为``long``)，并将字符串对象的编码设置为``int``。
![](..\md图片\71.png)
- 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于39字节，那么字符串对象将使用一个**简单动态字符串(SDS)** 来保存这个字符串，并将对象的编码设置为``raw``
![](..\md图片\72.png)
- 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用``embstr``编码的方式来保存这个字符串。
    ``embstr``编码是一种专门用于保存端字符串的一种优化编码方式。这种编码和``raw``编码一样，都使用``redisObject``结构和``sdshdr``结构来表示字符串对象，区别在于：
  - ``raw``编码会调用两次内存来分配``redisObject``结构和``sdshdr``结构。
  - ``embstr``编码只调用一次内存来分配一块连续的空间。
  ![](..\md图片\73.png)

  由于减少了内存分配的次数，以及将零散的内存整合到一起，这种编码的字符串对象比起``raw``编码能够更好地利用缓存带来的优势。

  如果保存浮点数，则会先转化为字符串类型保存。比如保存3.14就会先保存为"3.14"。但在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。


  下表是值和对应的编码类型
  |值|编码|
  |:-:|:-:|
  |可以用long类型保存的整数|int|
  |可以用long double类型保存的浮点数|embstr或者raw|
  |字符串值，长度太大没办法用long类型表示的参数|embstr或者raw|

### 2.2 编码转换
编码之间也会有互相转换的情况。对于``int``编码的字符串对象来说，如果因为命令导致这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从``int``变为``raw``。
```bash
redis> SET number 10086
OK
    
redis> OBJECT ENCODING number
"int"
    
redis> APPEND number " is a good number!"
(integer) 23
    
redis> GET number
"10086 is a good number!"
    
redis> OBJECT ENCODING number
"raw"
```
因为Redis没有为``embstr``编码的字符串对象编写任何相应的修改程序，所以``embstr``编码的字符串对象实际上是只读的。当修改``embstr``编码的字符串对象，程序会先将对象的编码从``embstr``转换成``raw``，然后再执行修改命令。

---

## 三、列表对象
### 3.1 编码方式
列表对象的编码可以是``ziplist``或者是``linkedlist``
如同前面提到的，压缩列表每个节点只保存一个列表元素。下面例子中，我们输入数字1，字符"three"，数字5。
```bash
redis > RPUSH numbers 1 "three" 5
(integer) 3
```
![](..\md图片\81.png)

如果使用的不是``ziplist``编码，而是``linkedlist``双端链表编码，那么

![](..\md图片\82.png)

这其实是一个嵌套编码，Redis使用了一个``StringObject``来表示一个字符串对象，编码方式如同字符串对象的三种编码方式。如果编码对象是字符串值，展开后就是：

![](..\md图片\83.png)

### 3.2 编码转换
当列表对象可以同时满足以下两个条件时，列表对象使用``ziplist``编码：
1.  列表对象保存的所有字符串元素的长度都小于64字节；
2.  列表对象保存的元素数量小于512个；

当上诉条件有一个不满足时，就会执行转换操作：原本保存在压缩列表里的所有列表元素都会被转移病保存到双端链表里面，对象的编码也会从``ziplist``变为``linkedlist``

---

## 四、哈希对象
### 4.1 编码方式
哈希对象的编码可以是``ziplist``或者``hashtable``
``ziplist``编码时，每当有新的键值对要加入到哈希对象时，程序会将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：
- 保存了同一键值对的两个节点总是紧挨在一起，键前值后。
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

比如：
```bash
redis> HSET profile name "Tom"
(integer) 1

redis> HSET profile age 25
(integer) 1

redis> HSET profile career "Programmer"
(integer) 1
```
![](..\md图片\91.png)

``hashtable``编码时，哈希对象中的每个键值对都使用一个字典键值对来保存：
- 字典的每个键都是一个字符串对象，对象中保存了键值对的键
- 字典的每个值都是一个字符串对象，对象中保存了键值对的值

比如，上面的例子改为``hashtable``编码
![](..\md图片\92.png)

### 4.2 编码转换
当哈希对象可以同时满足以下两个条件时，哈希对象使用``ziplist``编码：
1.  哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
2.  哈希对象保存的键值对数量小于512个

类似于列表对象，不满足条件时，原本保存在压缩列表中的所有键值对都会被转移并保存到字典里面，对象的编码也会从``ziplist``变为``hashtable``

---

## 五、集合对象
### 5.1 编码方式
集合对象的编码可以是``intset``或者``hashtable``
``intset``编码时，元素将被密集得堆叠在位上，比如
```c
redis > SADD numbers 1 3 5
(integer) 3
```
![](..\md图片\101.png)

另一方面，``hashtable``编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而**字典的值则全部设置为``NULL``**

![](..\md图片\102.png)

### 5.2 编码转换
当集合对象可以同时满足以下两个条件时，对象使用``intset``编码：
1.  集合对象保存的所有元素都是整数值
2.  集合对象保存的元素数量不超过512个

当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。

---

## 六、有序集合对象
### 6.1 编码方式
有序集合的编码可以是``ziplist``或者``skiplist``。
``ziplist``编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，第二个元素来保存元素的分值(score)。
```c
redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
```

![](..\md图片\111.png)

``skiplist``编码的有序集合对象使用``zset``结构作为底层实现，一个zset结构同事包含一个字典和一个跳跃表：
```c
typedef struct zset{
    zskiplist * zsl;
    dict * dict;
}zset;
```
起作用主要是跳跃表，字典是辅助加速用。字典的键记录了元素的成员，而值保存了元素的分值。通过字典可以实现$O(1)$的查询时间复杂度。

有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个``double`` 类型的浮点数。

虽然 ``zset`` 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。

### 6.2 编码转换
当有序集合对象可以同时满足以下两个条件时， 对象使用 ``ziplist`` 编码：
1.  有序集合保存的元素数量小于 128 个；
2.  有序集合保存的所有元素成员的长度都小于 64 字节；

不能满足以上两个条件的有序集合对象将使用 ``skiplist`` 编码。

## 七、内存回收、对象共享、空转时长
对象中包括了一个引用计数器：
```c
typedef struct redisObject{
    //引用计数

    int refcount;
}robj;
```
对象的引用计数信息会随着对象的使用状态而不断变化：
- 在创建一个新对象时， 引用计数的值会被初始化为 1 ；
- 当对象被引用时，计数值+1；
- 当对象不再被引用时，计数值-1；
- 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。

|函数|作用|
|:-:|:-:|
|incrRefCount|将对象的引用计数增一|
|decrRefCount|讲对象的引用计数值减一，当对象的引用计数值等于0时，释放对象。|
|resetRefCount|将对象的引用计数值设置为0，但并不释放对象，这个函数通常在需要重新设置对象的引用计数值时使用|
通过引用机制，还能实现对象共享。**共享只针对整数值对象，不针对包含字符串的对象。**

假设键A创建了一个包含整数值100的字符串对象作为值对象
![](..\md图片\121.png)

如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有两种做法：
1.  为键B新创建一个包含整数值100的字符串对象
2.  让键A和键B共享一个字符串对象

以上两种方法很明显是第二种方法更节约内存。在Redis中，让多个键共享同一个值对象需要执行以下两个步骤，

1.  将数据库键的值指针指向一个现有的值对象；
2.  将被共享的值对象的引用计数增一；

Redis会在初始化服务器的时候，创建一万个字符串对象，这些对象包含了从0~9999的所有整数值，当服务器需要用到值为0~9999的字符串对象时，服务器就会使用这些共享对象，而不是新建对象。

**为什么Redis不共享字符串的对象？**
|共享对象|复杂度|
|:-:|:-:|
|保存整数值字符串对象|$O(1)$|
|保存字符串值的字符串对象|$O(N)$|
|包含了多个值的对象（列表或哈希）|$O(N^2)$|

``redisObject``结构包含的最后一个属性为``lru``属性，该属性记录了对象最后一次被命令程序访问的时间：
```c
typedef struct redisObject{
    unsigned lru :22;
}robj;
```
``OBJECT IDLETIME`` 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 ``lru`` 时间计算得出的：

```bash
redis> SET msg "hello world"
OK

# 等待一小段时间
redis> OBJECT IDLETIME msg
(integer) 20
```
注意``OBJECT IDLETIME``命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的``lru``属性。
当内存满时，空转时长较长的键会被优先释放。



