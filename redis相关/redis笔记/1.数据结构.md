[toc]
# Redis中的数据结构

## 一、简单动态字符串

### 引言
Redis中没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种简单动态字符串（SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。

在Redis中，C字符串只会用在一些无须修改的地方，比如打印常量：
```c++
redislog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");
```
如果是在需要修改的地方，则会使用SDS来表示：
```bash
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```
Redis将在数据库中创建一个新的键值对，其中：
- key是一个**字符串对象**，底层包含了一个字符串fruits的SDS。
- value是一个**列表对象**，底层包含了三个字符串对象，由SDS实现。

### 1.1 SDS的定义
SDS是一个结构体，定义在sds.h/sdshdr中：
```c++
struct{
    //记录buf数组中已经使用的字节的数量
    //等于SDS所保存字符串的长度
    int len;
    //记录buf数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[];
}
```
下面给出了一个示例：free=0表示所有空间都被使用，未使用空间为0。len=5表示SDS字符串长度为5。buf就是字符串实体。
![image](..\md图片\11.png)
保存空字符的1字节空间不计算在len之内。遵循空字符结尾这一原则，SDS可以直接重用一部分C字符串函数库里的函数。
比如：
```c
printf("%s",s->buf)
```

### 1.2 SDS与C字符串的区别
C语言使用的简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。主要有以下几个弊端。
- **获取字符串长度的效率：** 
C字符串需要遍历字符串才能得到长度，时间复杂度为O(n)。SDS底层维护了一个len，所以获取字符串长度的时间复杂度为O(1)。
- **杜绝缓冲区溢出：**
  由于C字符串不记录长度，当我们拼接两个字符串的时候，容器可能因为空间不足发生溢出。redis中的sdscat将在执行拼接操作前检查长度是否充足，若不足则先拓展空间，再拼接。
- **减少修改字符串长度时所需的内存分配次数：**
C字符串类似于数组，每次修改大小都会重新分配内存。Redis的分配原理类似于```std::vector```，通过空间预分配的办法优化字符串增加，分配规则如下：
    - len小于1MB，则free和len一样大。例如修改后len为13字节，free也为13字节，buf的实际长度就位13 + 13 + 1 = 27字节
    - len大于1MB，则free为1MB。例如修改后len为30MB，free为1MB，buf的实际长度为1MB + 30MB + 1byte
- **二进制安全：**
C字符串使用``\0``结尾，使得C字符串只能保存文本数据，不能保存像图片、音频、视频、压缩文件这样的二进制数据。
SDS使用len来判断是否结束，而不是``\0``。
- **兼容部分C语言函数：**
因为SDS也遵循使用``\0``结尾的规则，所以SDS也可以使用```<string.h>```中的部分函数。

---

## 二、链表
### 引言
链表随机读写能力较差O(n)，但增删和重排能力较强。C语言没有链表结构，Redis自制了一个链表。

### 2.1 链表和链表节点的实现
每个链表节点使用一个``adlist.h/listNode``结构来表示
```c
typedef struct listNode{
    //前置节点
    struct listNode * prev;
    //后驱节点
    struct listNode * next;
    //节点的值
    void *value;
}listNode;
```
多个Node组成一个**双端链表**
![image](..\md图片\21.png)
但是为了方便，Redis设计了``adlist.h/list``来持有链表。
```c
typedef struct list {
    //表头节点
    listNode * head;
    //表尾节点
    listNode * tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数
    void *(*dup)(void * ptr)
    //节点值释放函数
    void (*free)(void * ptr)
    //节点值对比函数
    int (*match)(void * ptr,void * key)
}
```
**Redis的链表实现的特性可以总结如下：**
- **双端**
- **无环，表头和结尾都指向null**
- **带有表头表尾指针，访问首尾都是O(1)**
- **多态，链表节点使用void * 指针来保存节点值**

---

## 三、字典
### 引言
在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。字典中的每个键必须保证都是独一无二的。C并没有这样的结构，所以Redis自己实现了。

### 3.1 字典的实现
Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多哥哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
#### 3.1.1 哈希表
Redis字典使用的哈希表由``dict.h/dictht``结构定义：
```c
typedef struct dictht{
    //哈希表数组指针
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码，用于计算索引值，总是等于size - 1
    unsigned long sizemask;
    //该哈希表已有节点的数量
    unsigned long used;
}
```
``table``是一个数组，**数组中的每个元素**都是指向```dict.h/dictEntry```的**指针**

![](..\md图片\31.png)




---

#### 3.1.2 哈希表节点
哈希表节点使用``dictEntry``结构表示，每个``dictEntry``结构都保存一个键值对：
```c
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```


``v`` 属性则保存着键值对中的值， 值可以是一个指针， 或者是一个 ``uint64_t`` 整数， 又或者是一个 int64_t 整数。

``next`` 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来**解决键冲突（collision）的问题**

下图中，键的索引值都是2，通过链表的形式完成了冲突的规避。
![image](..\md图片\32.png)

---

#### 3.1.3 字典
Redis中的字典由```dict.h/dict```结构表示
```c
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
} dict;
```
其中``type``属性和``privdata``属性是针对不同类型的键值对，为创建多态字典而设置的。
- ``type``属性是一个指向``dictType``结构的指针，每个``dictType``结构保存了一簇用于操作特定类型键值对的函数。
- ``privdata``属性则保存了需要传给那些类型特定函数的可选参数

```c
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);

    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);

    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);

    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);

    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);

    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```
哈希表数组ht包含了两个元素，一般情况下，字典只使用``ht[0]``哈希表，``ht[1]``哈希表只会在对``ht[0]``哈希表进行rehash时使用。
除了``ht[1]``之外，另一个和rehash有关的属性是``rehashidx``：它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。
下图为一个普通状态下（没有rehash）的字典
![](..\md图片\33.png)

### 3.2 哈希算法
程序需要先根据键值对的键计算出**哈希值和索引值**，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。
Redis计算哈希值和索引值的方法如下：
```c
//使用字典设置的哈希函数，计算出键key的哈希值
hash = dict->type->hashFunction(key)
//使用哈希表的sizemask属性和哈希值，计算出索引值
//根据情况不同，ht[x]可能是ht[0]或者ht[1]
index = hash & dict->ht[x].sizemask
```
举个例子，加入想要将键值对<k0,v0>添加到下面的字典中。
![](..\md图片\34.png)
假设计算出的哈希值为8，则index的计算方式为：
```c
index = hash & dict->ht[0].sizemask-1 = 8 & 3 = 0
```
![](..\md图片\35.png)

至于Redis的哈希值计算方法，使用的是**MurmurHash2**。这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。

### 3.3 Rehash
随着操作的不断执行，哈希表保存的键值对会逐渐地增多或减少，为了让哈希表的**负载因子（load Factor）** 维持在一个合理的范围之内，**当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。**
Rehash的关键在于**重新分配哈希表的大小**，分配的原则如下：
- 如果执行拓展操作，``ht[1]``的大小为第一个大于等于``ht[0].used * 2``的$2^n$。
- 如果执行收缩操作，``ht[1]``的大小为第一个大于等于``ht[0].used``的$2^n$

完成分配后，将保存在``ht[0]``中的所有键值对rehash到``ht[1]``上面，然后将``ht[1]``设置为``ht[0]``，并在``ht[1]``新创建一个空白哈希表，为下一次rehash做准备。
决定是和否Rehash的要素来自于负载因子，计算方法如下：
```c
//负载因子 = 哈希表已保存节点数量 / 哈希表大小
load_factor = ht[0].used / ht[0].size
```

### 3.4 渐进式Rehash

#### 3.4.1 渐进式rehash的操作
如果键值对很多，则将``ht[0]``重新hash到``ht[1]``上，则会导致服务器在一段时间内停止服务。为了避免这种问题，需要分多次渐进式的慢慢映射。

关键点在于维持一个**索引计数器变量**``rehashidx``，并将它的值设为0，表示``rehash``工作正式开始。
在``rehash``进行期间，每次对字典执行增删改查，程序除了执行指定的操作以外，还会顺带将``ht[0]``哈希表在``rehashidx``索引上的所有键值对``rehash``到``ht[1]``上，当``rehash``工作全部完成之后，程序将``rehashidx``属性的值增一。

全部操作完成后，程序将``rehashidx``的值设为-1，表示``rehash``操作已经完成。

渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个增删改查上， 从而避免了集中式 rehash 而带来的庞大计算量。


#### 3.4.2 渐进式rehash执行期间的哈希表操作

因为在进行渐进式rehash的过程中，字典会同时使用``ht[0]``和``ht[1]``两个哈希表，所以在渐进式rehash期间，字典的操作分为两种。
- **删除、更改、查询：** 会在两个哈希表中进行操作。例如要在字典里面查找一个键的话，程序会先在``ht[0]``里面进行查找，如果没找到的话，就会继续到``ht[1]``里面进行查找。删除、更改也如此。
- **增加：** 只会在``ht[1]``里面进行保存，不会再``ht[0]``中操作，这一措施保证了``ht[0]``包含的键值对数量只减不增，并随着rehash的操作执行而变成空表。

--- 

## 四、跳跃表

### 引言
我们知道链表随机读写的能力很差，当增删改查的时候，如果要找到目标元素就需要遍历链表，时间复杂度为O(n)。假设某个数据结构是有序的，我们会想到使用二分查询来快速查找，**但是链表是没有索引的**，所以我们需要为链表添加索引。
**跳表的平均查找和插入时间复杂度都是**$O(logN)$。
快速查询是通过维护一个多层次的链表，且每一层的链表中的元素都是前一层链表元素的子集。一开始，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。

![](..\md图片\41.png)

### 4.1 跳跃表的实现
Redis的跳跃表由``redis.h/zskiplistNode``和``redis.h/zskiplist``两个结构定义，其中``zskiplistNode``结构用于表示跳跃表的节点，而``zskiplist``结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头表尾节点的指针。

![](..\md图片\42.png) 

#### 4.1.1 跳跃表节点

``zskiplistNode``的定义如下：
```c
typedef struct zskiplistNode{

    //后退指针
    struct zskiplistNode * backward;

    //分值
    double score;

    //成员对象
    robj *obj;

    //层
    struct zskiplistLevel{
        //前进指针
        struct zskiplistNode * forward;
        //跨度
        unsigned int span;
    }level[];

}zskiplistNode;
```
- **层(level)**：
每次创建一个新跳跃表节点的时候，程序都根据幂次定律(power law，越大的数出现的概率越小)**随机**生成一个介于1~32之间的值作为``level``数组的大小，这个大小就是层的**高度**。
- **前进指针**：
前进指针分属于不同的层，用于访问位于表尾方向的其他节点。
- **跨度**：
跨度也分属不同的层，指向``NULL``的所有前进指针的跨度为0，则记录了前进指针所指向节点和当前节点的距离。
跨度实际上是用来计算位次(rank)的：**将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。**
- **后退指针**：
节点的后退指针(backward属性)用于从表尾向表头方向访问节点，但是只能每次只能后退一个节点。
- **分值和成员**：
节点的分值(score属性)是一个double类型的浮点数，所有节点都使用分值从小到大排序。
节点的成员(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。
**排序规则**：在跳跃表中，各个节点保存的对象必须是唯一的，但是多个节点的分值可以相同。首先按照分值从小到大排序，如果分值相同则根据成员对象的字典序排序。

#### 4.1.2 跳跃表
使用一个``zskiplist``结构来管理``zskiplistNode``节点，程序可以更方便地对整个跳跃表进行管理。
```c
typedef struct zskiplist{
    //表头节点和表尾节点
    struct zskiplistNode * tail,* header;

    //表中节点的数量
    unsigned long length;

    //表中层数最大的节点的层数
    int level;

}zskiplist;

```
## 五、整数集合

### 引言
当一个集合中只包含整数，并且元素的个数不是很多的话，redis会用整数集合作为底层存储，它可以节省很多内存。

### 5.1 整数集合的实现
整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为``int16_t``、``int32_t``、``int64_t``的整数值，并且保证集合中不会出现重复元素。

每个``intset.h/intset``结构表示一个整数集合：
```c
typedef struct intset{
    //编码方式
    uint32_t encoding;

    //集合包含的元素数量
    uint32_t length;

    //保存元素的数组
    int8_t contents[];
}intset;
```
- **contents** 数组是整数集合的底层实现：
整数集合的每个元素都是``contents``数组的一个数组项(item)，从小到大有序地排列，不包含任何重复项。
虽然``intset``结构将``contents``属性声明为``int8_t``类型的数组，但实际上``contents``数组并不保存任何``int8_t``类型的值——**``contents``数组的真正类型取决于``encoding``属性的值**:
  - ``encoding`` 为`` INTSET_ENC_INT16，int16_t`` 类型的数组，范围$[-2^{16},2^{16}-1]$
  - ``encoding`` 为``INTSET_ENC_INT32`` ， 是一个 ``int32_t`` 类型的数组。
  - ``encoding`` 为 ``INTSET_ENC_INT64`` ， 是一个 ``int64_t`` 类型的数组
下图是一个实例：
![](..\md图片\51.png)
### 5.2 升级
#### 5.2.1 升级的过程
每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合元素的类型长时，整数集合需要先进行升级(upgrade)，然后才能将新元素添加到整数集合里面。
过程如下：
- 根据新类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
- 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素有序放置。
- 将新元素添加到底层数组里面

假设想要在16位编码的intset中插入一个32位的65535数据，原来的集合是这样的
![](..\md图片\52.png)
需要扩容位$32 \times 4 = 12$
![](..\md图片\53.png)

剩下的就要对元素重排。
先将3移动到新intset结构的索引2的位置上，然后将2移动到索引1的位置，然后将1移动到索引0的位置。最后再将65535移动到索引3的位置。

#### 5.2.2 升级的好处
- **提升灵活性**
  可以随意地将``int16_t、int32_t、int64_t``类型添加到集合中，而不必担心出现类型错误。
- **节约内存**
  想要保存三种int类型的话，最简单的方法是直接使用int64_t来保存。而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。
### 5.3 降级
整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

即使我们将集合里唯一一个真正需要使用 ``int64_t`` 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 ``INTSET_ENC_INT64``。
  
---

## 六、压缩列表

### 引言
压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值或长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。

### 6.1 压缩列表的构成
压缩列表是Redis为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。
![](..\md图片\61.png)


|属性|类型|长度|作用|
|:-:|:-:|:-:|:-:|
|zlbytes|uint32_t|4字节|整个压缩列表占用内存字节数|
|zltail|uint32_t|4字节|记录表尾节点距离表起始地址有多少个字节|
|zllen|uint16_t|2字节|记录节点数量|
|entryX||不定|节点|
|zlen|uint8_t|1字节|用于标记末端|

![](..\md图片\62.png)
- ``zlbytes``属性的值为``0x50``(十进制80)，表示压缩列表总长为80字节
- ``zltail``属性的值为``0x3c``(十进制60)，如果一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点``entry3``的地址。
- ``zllen``属性的值为``0x3``(十进制3)，表示压缩列表包含三个节点。

### 6.2 压缩列表的节点构成

每个压缩列表节点可以保存一个字节数组或一个整数值，其中，字节数组可以是以下三种长度的其中一种：
- 长度小于等于`63`($2^6-1$)字节的字节数组。
- 长度小于等于`16383`($2^{14}-1$)
- 长度小于等于`4294967295`($2^{32}-1$)

而整数值则可以是一下六项长度的其中一种：
- ``4``位长，介于`0`和`12`之间的无符号整数
- `1`字节长的有符号整数
- `3`字节长的有符号整数
- `int16_t`类型整数
- `int32_t`类型整数
- `int64_t`类型整数

每个压缩列表节点都由`previous_entry_length`、`encoding`、`content`三个部分构成。

**previous_entry_length** 
以字节为单位，记录了压缩列表中前一个节点的长度。这个属性的长度可以是1字节或5字节，如果前一个小于254则使用1字节，反之使用5字节 **（其中属性的第一字节会被设置为``0xFE``(十进制254)，而之后的四个字节则用于保存前一节点的长度）**
因为节点的`previous_entry_length`属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。

例如：现在有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p。
``p = c - current_entry.previous_entry_length``


**encoding**
节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。编码由8位组成。
如果是字符类型，则开头两位00，01，,01分别表示1字节，2字节，5字节，后6位表示字符串长度。
保存每个元素是一个字节的数组，长度11。
![](..\md图片\63.png)

如果是整数类型，则开头必定是11，然后从第六位开始往低位开始计数：

![](..\md图片\64.png)

每个元素``int16_t``，值为10086
![](..\md图片\65.png)

### 6.3 连锁更新
每个节点的``previous_entry_length``属性都记录了前一个节点的长度：
- 如果前一节点的长度小于``254``字节，那么``previous_entry_length``属性需要用``1``字节长的空间来保存这个长度值
- 如果前一节点的长度大于等于``254``字节，那么``previous_entry_length``属性需要用``5``字节长的空间来保存这个值。
假设现在有一些长度为252字节的节点，他们在各个节点的``previous_entry_length``中保存为1字节。现在插入了一个260字节的新节点，``new``将成为``e1``的前置节点。

![](..\md图片\66.png)
因为``e1``的``previous_entry_length``的变化，导致``e1``的长度也发生了变化$252+4=256>254$，所以导致``e2``也必须更新他的``previous_entry_length``。这就是连锁更新。

除了添加节点外，删除节点也会导致连锁更新，若删除一个260字节的节点，则后一个节点长度也会变化。如果很不凑巧，小于254，则又会引起后续效应。

连锁更新在最坏情况下需要对压缩列表执行``N``次空间重分配操作，而每次空间重分配的最坏复杂度为$O(N)$，所以连锁更新的最坏复杂度为$O(N^2)$。





