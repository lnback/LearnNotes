[toc]
# Redis中的数据结构

## 一、简单动态字符串

### 引言
Redis中没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种简单动态字符串（SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。

在Redis中，C字符串只会用在一些无须修改的地方，比如打印常量：
```c++
redislog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");
```
如果是在需要修改的地方，则会使用SDS来表示：
```bash
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```
Redis将在数据库中创建一个新的键值对，其中：
- key是一个**字符串对象**，底层包含了一个字符串fruits的SDS。
- value是一个**列表对象**，底层包含了三个字符串对象，由SDS实现。

### 1.1 SDS的定义
SDS是一个结构体，定义在sds.h/sdshdr中：
```c++
struct{
    //记录buf数组中已经使用的字节的数量
    //等于SDS所保存字符串的长度
    int len;
    //记录buf数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[];
}
```
下面给出了一个示例：free=0表示所有空间都被使用，未使用空间为0。len=5表示SDS字符串长度为5。buf就是字符串实体。
![image](..\md图片\11.png)
保存空字符的1字节空间不计算在len之内。遵循空字符结尾这一原则，SDS可以直接重用一部分C字符串函数库里的函数。
比如：
```c
printf("%s",s->buf)
```

### 1.2 SDS与C字符串的区别
C语言使用的简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。主要有以下几个弊端。
- **获取字符串长度的效率：** 
C字符串需要遍历字符串才能得到长度，时间复杂度为O(n)。SDS底层维护了一个len，所以获取字符串长度的时间复杂度为O(1)。
- **杜绝缓冲区溢出：**
  由于C字符串不记录长度，当我们拼接两个字符串的时候，容器可能因为空间不足发生溢出。redis中的sdscat将在执行拼接操作前检查长度是否充足，若不足则先拓展空间，再拼接。
- **减少修改字符串长度时所需的内存分配次数：**
C字符串类似于数组，每次修改大小都会重新分配内存。Redis的分配原理类似于```std::vector```，通过空间预分配的办法优化字符串增加，分配规则如下：
    - len小于1MB，则free和len一样大。例如修改后len为13字节，free也为13字节，buf的实际长度就位13 + 13 + 1 = 27字节
    - len大于1MB，则free为1MB。例如修改后len为30MB，free为1MB，buf的实际长度为1MB + 30MB + 1byte
- **二进制安全：**
C字符串使用``\0``结尾，使得C字符串只能保存文本数据，不能保存像图片、音频、视频、压缩文件这样的二进制数据。
SDS使用len来判断是否结束，而不是``\0``。
- **兼容部分C语言函数：**
因为SDS也遵循使用``\0``结尾的规则，所以SDS也可以使用```<string.h>```中的部分函数。

## 二、链表





