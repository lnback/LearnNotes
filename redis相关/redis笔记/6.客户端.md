# 客户端和服务器

## 一、客户端
Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，处理他们的请求。

通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。

对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息。

在服务器中，用一个链表保存客户端的所有状态

```c
struct redisServer 
{ 
    // ... 
    // 一个链表，保存了所有客户端状态 
    list *clients; 
    // ...
};
```
![](..\md图片\16_1.png)

### 1.1 客户端属性

**（1）套接字描述符**

客户端状态的fd属性记录了客户端正在使用的套接字描述符。根据客户端类型不同，fd的值可以是 **-1或大于-1的整数** ：
- 伪客户端为-1：伪客户端用于处理的AOF文件或Lua脚本，而不是网络。
- 普通客户端为大于-1的整数。

执行CLIENT list命令会列出所有连接到服务器的普通客户端。
```bash
redis> CLIENT list
addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0 ...
addr=127.0.0.1:53469 fd=7 name= age=4 idle=4 ...
```

**（2）名字**

默认情况下客户端是没有名字的，比如上面的例子中name处就是空白。使用**CLIENT setname**命令可以为客户端设置一个名字，让客户端的身份变得更清晰。
```c
typedef struct redisClient
{
    //...
    robj *name;
    //...
}redisClient;
```
如果客户端没有名字，那么相应客户端状态的name属性指向NULL指针；相反，如果有名字，那么name属性将指向一个字符串对象。

**（3）标志**

客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态：
```c
typedef struct redisClient 
{ 
    // ... 
    int flags; 
    // ...
} redisClient;
```
比如``REDIS_BLOCKED``标志表示客户端正在被BRPOP、BLPOP等命令阻塞。flag可以是单个标志，也可以是多个标志的组合。比如：
```c
flags=REDIS_SLAVE | REDIS_PRE_PSYNC;
```

**（4）输入缓冲区**

客户端状态的输入缓冲区用于**保存客户端发送的命令请求：**
```c
typedef struct redisClient 
{ 
    // ... 
    sds querybuf; 
    // ...
} redisClient;
```
保存方式和AOF类似，比如SET key value被转化为如下的SDS值：

```c
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```

![](..\md图片\16_2.png)

**（5）命令与命令参数**

在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性：
```c
typedef struct redisClient 
{ 
    // ... 
    robj **argv;
    int argc;
    // ...
} redisClient;
```
``argv``属性是一个数组，数组中的每个项都是一个字符串对象，其中``argv[0]``是要执行的命令，而之后的其他项则是传给命令的参数。
![](..\md图片\16_3.png)

**（6）命令的实现函数**

当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。

命令表是一个字典结构，键是SDS结构，保存了命令的名字，值是redisCommand结构，保存了：

- 实现函数
- 命令标志
- 命令的参数个数
- 命令的总执行次数
- 总消耗时长

当程序在命令表中成功找到``argv[0]``所对应的redisCommand结构时，客户端状态的cmd指针指向这个结构：
```c
typedef struct redisClient 
{ 
    // ... 
    struct redisCommand *cmd;
    // ...
} redisClient;
```
服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。

**（7）输出缓冲区**

命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有**两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的**：

- 固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。
- 可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。

**（8）身份验证**

客户端状态的authenticated属性用于记录客户端是否通过了身份验证：
```c
typedef struct redisClient 
{ 
    // ... 
    int authenticated;
    // ...
} redisClient;
```
为0表示没有通过验证，为1表示通过。如果没有通过，除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行。
```bash
redis> SET msg "hello world"
(error) NOAUTH Authentication required.
```

当客户端通过AUTH命令成功进行身份验证之后，客户端状态authenticated属性的值就会从0变为1.

**（9）时间**

客户端还有几个和时间有关的属性：
```c
typedef struct redisClient 
{ // ... 
    time_t ctime; 
    time_t lastinteraction; 
    time_t obuf_soft_limit_reached_time; // ...
} redisClient;
```
- ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。
- lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间。（收或者发命令）
- obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间

### 1.2 创建与关闭客户端
**（1）普通客户端**

所谓普通客户端是指客户端通过网络与服务器连接，客户端使用connect函数连接到服务器时就会调用连接事件处理器。

之后，会将新客户端的状态添加到clients链表的末尾。
![](..\md图片\16_4.png)
关闭的原因可能有很多种

- 客户端进程退出或被杀死
- 客户端向服务器发送了带有不符合协议格式的命令请求
- 如果客户端成为了CLIENT KILL命令的目标
- 客户端空转超时
- 客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB）
- 如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小

除了超过1GB大小的硬性限制外，还有软性限制，用到了之前提到的``obuf_soft_limit_reached_time``属性。

如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的``obuf_soft_limit_reached_time``属性记录下客户端到达软性限制的起始时间。之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端

**（2）Lua脚本的伪客户端**

服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：
```c
struct redisServer 
{ 
    // ... 
    redisClient *lua_client; 
    // ...
};
```
Lua脚本会一直存在于服务器生命周期，只有服务器被关闭时他才会停止。

服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。

## 二、服务器

### 2.1 命令请求的执行过程


### 2.2 severCron函数

### 2.3 服务器初始化