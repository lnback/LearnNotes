# go的内存分配器

## 设计原理
内存管理一般包含三个不同的组件，用户程序（Mutator）、分配器（Allocator）、收集器（Collector），当用户程序申请内存时，他会通过内存分配器申请新的内存，而分配器会负责从堆中初始化相应的内存区域。
![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210111194327.png)
### 分配方法
编程语言的内存分配器一般包含两种分配方法，一种是线性分配器，另一种是空闲链表分配器。
#### 线性分配器
线性分配是一种高效的内存分配方式，但是有较大的的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存，返回分配的内存区域并修改指针在内存中的位置。

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210111194354.png)

根据线性分配器的原理，它有较快的执行速度，以及较低的实现复杂度；但是线性分配器无法在内存被释放时重用内存。如果已经分配的内存被回收，线性分配器是无法重新利用这块内存的：

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210111201623.png)

所以在垃圾回收时，需要合适的垃圾回收算法配合使用。标记-整理、复制回收、分代回收等算法都可以通过拷贝整理存活对象的碎片，将空闲内存定期合并。

#### 空闲链表分配器
空闲链表分配器可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够的内存，然后申请新的资源并修改链表。

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210111202528.png)

空闲链表分配器可以选择不同的策略正在链表中的内存块进行选择，最常见的就是以下四种方式：
- 首次适应：从链表头开始遍历，选择第一个大于申请内存大内存块
- 循环首次适应：从上次遍历结束的位置开始遍历，选择第一个大小大于申请内存的内存块
- 最优适应：从链表头遍历整个链表，选择最合适的内存块
- 隔离适应：将内存分割成多个链表，每个链表中内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块。

go语言使用的内存分配策略和第四种策略有些相似

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210111203808.png)

如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，我们会在上图中的第二个链表找到空闲的内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。

### 分级分配
线程缓存分配(TCMalloc)是用于分配内存的机制，他比glibc中的`malloc`还要快很多。Go语言的内存分配机制就借鉴了TCMalloc的设计实现高速的内存分配。它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。
#### 对象大小
根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：
|类别|大小|
|-|-|
|微对象|`(0,16b)`|
|小对象|`[16b,32kb]`|
|大对象|`(32kb,+∞)`|
因为绝大多数对象的大小都在32KB以下，而申请的内存大小影响Go语言运行时分配内存的过程和开销，所以分别处理大小对象有利于提高内存分配器的性能。
#### 多级缓存
内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc和Go运行时分配器都会引入线程缓存(Thread Cache)、中心缓存(Central Cache)和页堆(Page Heap)三个组件分级管理内存。

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210112111521.png)

线程缓存属于每一个独立的线程，他能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，就会使用中心缓存作为补充解决小对象的内存分配问题；在遇到32KB以上的对象时，内存分配器就会选择页堆直接分配大量的内存

### 虚拟内存布局
在Go 1.10以前的版本中，堆区的内存都是连续的；在1.11版本后，Go使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题
#### 线性内存
Go语言程序在1.10版本启动时会初始化正片虚拟内存区域，如下所示的三个区域`spans`,`bitmap`,`arena`分别预留了512MB、16GB、512GB的内存空间，这些不是物理上的是虚拟的。

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210112140943.png)

- `spans`存了指向内存管理单元`runtime.mspan`的指针，每个内存单元会管理几页的内存空间，每页大小为8KB
- `bitmap`用于标识`arena`区域中的那些地址保存了对象，位图的每个字节都表示堆区中的32字节是否空闲
- `arena`区域是真正的堆区，运行时8KB看做一页，这些内存页中存储了所有堆上初始化的对象

对于任意一个地址：都可以根据`arena`的基地址计算该地址所在的页数并通过`spans`数组获得管理该页的管理单元`runtime.mspan`

Go 语言在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上一段中介绍的过程找到管理该对象的 runtime.mspan。这些都建立在堆区的内存是连续的这一假设上。这种设计虽然简单并且方便，但是在 C 和 Go 混合使用时会导致程序崩溃：
1.  分配的内存地址会发生冲突，导致堆的初始化和扩容失败
2.  没有被预留的大块内存可能会被分配给C语言的二进制，导致扩容后的堆不连续

#### 稀疏内存
使用稀疏的内存布局不仅能够移除堆大小的上限，还能解决C和Go混合使用时的地址空间冲突问题。但同样会使管理非常复杂。

![](https://cdn.jsdelivr.net/gh/lnback/imgbed/img/20210112141112.png)

**二维稀疏内存**
### 地址空间
#### 
## 内存管理组件
### 内存管理单元
### 线程缓存
### 中心缓存
### 页堆

## 内存分配
### 微对象
### 小对象
### 大对象

## 总结