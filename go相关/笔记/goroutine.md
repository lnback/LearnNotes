# Go语言的并发
## Go并发调度：G-P-M 模型
### 1. GPM模型
![](..\图片\1_1.png)
- G：Goroutine的简称，上面用go关键字家函数调用的代码就是创建了一个G对象。
- M：Machine的简称，代表一个线程，每次创建一个M的时候，都会有底层线程创建；所有的G任务，最终都是在M上执行。
- P：代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在一个CPU核上运行一样。
P的个数就是**GOMAXPROCS（最大256）**，启动时固定的，一般不修改； M的个数和P的个数不一定一样多（会有休眠的M或者不需要太多的M）（最大10000）；每一个P保存着本地G任务队列，还有一个全局G任务队列；

全局G任务队列会和各个本地G任务队列按照一定的策略互相交换（满了，则把本地队列的一半送给全局队列）

P是用一个全局数组（255）来保存的，并且维护着一个全局的P空闲链表

什么时候创建一个M：当用go创建一个新的goroutine时，即调用newProcess时，会检查是否有P，如果有就会为这个P找一个M，如果没有M，则会新建M。

### 2. 调度过程
假如我们有一个G(G1)已经通过P被安排到了一个M上正在执行，在G1执行的过程中我们又创建两个G，这两个G会被马上放入与Goroutine1相同的P的本地G任务队列中，排队等待与该P绑定的M的执行，这是最基本的结构，很好理解。

有几个问题：
1.  如何在一个多核心系统上尽量分配G到多个M上运行，充分利用多核，提高并发能力？
2.  如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？
3.  如果某一个G在M运行时间过长，有没有办法做抢占式调度，让该M上的其他G获得一定的运行时间，以保证调度系统的公平性?

#### 第一个问题

如果我们在一个Goroutine中通过go关键字创建了大量G，这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P（系统内P的数量默认等于系统cpu核心数），Go运行时系统始终能保证**至少有一个（通常也只有一个）活跃的M与空闲P绑定**去各种G队列去寻找可运行的G任务，**该种M称为自旋的M**。

一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。如果自己P队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中一次性转移(全局G个数/P个数），避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。

这样就保证了在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务)。

这里还有一个问题：M+P寻找空闲的G时，首先会以1/61的概率去从全局队列中获取G（避免饥饿），如果没有则从本地队列中寻找G，本地找不到就去全局中寻找（因为前面仅仅是1/61的概率）

#### 第二个问题

在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了。

但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G，大致过程如下图所示。然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。

#### 第三个问题

有一个线程sysmon，用来监控和管理，在内部是一个循环：
1.  记录所有P的G任务技术schedtick（schedtick会在每执行一个G任务后递增）
2.  如果检查到 schedtick一直没有递增，说明这个P一直在执行同一个G任务，如果超过一定的时间（10ms），就在这个G任务的栈信息里面加一个标记
3.  然后这个G任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G。
4.  如果没有遇到非内联函数（有时候正常的小函数会被优化成内联函数）调用的话，那就惨了，会一直执行这个G任务，直到它自己结束；如果是个死循环，并且GOMAXPROCS=1的话，会直接死机。

对于一个G任务，中断后的回复过程：
1.  中断的时候将寄存器里的栈信息保存到自己的G对象里面。
2.  当再次轮到自己执行的时候，将自己保存的栈信息复制到寄存器里面，就可以接着上次之后运行了。

### 3. 总结
goroutine是按照抢占式调度的，一个goroutine最多执行10ms就会换做下一个
这个和目前主流系统的cpu调度类似（按照时间分片）
windows：20ms
linux：5ms-800ms

