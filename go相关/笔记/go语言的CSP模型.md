# Go语言的CSP模型
go语言的两个亮点：一个是goroutine，一个就是channel。二者合体的典型应用CSP，就是大家认可的并行开发神器。
## 1.1 什么是CSP？
CSP是Communicating Sequential Process的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立并发实体通过共享的通讯channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，他不关注发送消息的实体，而关注与发送消息时使用的channel。

严格来说，CSP是一门形式语言，用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了Occam/Limbo/Golang

而具体到编程语言，如Golang，其实只用到了CSP的很小一部分，即理论中的Process/Channel(对应到语言中的goroutine/channel)。这两个并发原语之间没有从属关系，Process可以订阅任意个Channel，Channel也并不关心是哪个Process在利用它进行通信；Process围绕Channel进行读写，形成一套有序阻塞和可预测的并发模型。
## 1.2 Golang CSP
与主流语言通过共享内存来进行并发控制方式不同，Go语言采用CSP模式。这是一种用于描述两个独立的并发实体通过共享的通讯Channel（管道）进行通信的并发模型。

Golang就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际出发，Go语言并没有完全实现了CSP模型的所有理论，仅仅是借用了process和channel这两个概念。process在go语言上的表现就是goroutine，goroutine是实际并发执行的实体，每个实体之间利用channel实现数据共享。

Go语言的CSP模型是由协程goroutine和通道channel实现的：
- goroutine：是一种轻量线程，他不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程。
- channel：类似于Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是他们和channel有着耦合。
## 1.3 Channel
goroutine和channel是Go语言并发编程的两大基石。goroutine用于执行并发任务，channel用于goroutine之间的同步、通信。

channel在goroutine间架起了一条管道，在管道里传输数据，实现goroutine间的通信，实现了goroutine之间的通信；由于它是线程安全的，所以用起来很方便；channel还提供“先进先出的特性”；他还能影响goroutine的阻塞和唤醒。

### 1.3.1 channel实现CSP
使用原子函数、读写锁可以保证资源的共享访问安全，但使用channel更优雅。
channel字面意义是“通道”，类似于linux中的管道。声明channel的语法如下：
```go
chan T // 声明一个双向通道
chan <- T //声明一个只能用于发送的单向通道
<-chan T //声明一个只能用于接收的单向通道
```

单向通道的声明，用 <- 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。

因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。

两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是 “发送 -> 接收 -> 发送 -> 接收 -> ……”，如果想连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第一次一定会被阻塞；对于缓冲型 channel 的操作，则要 “宽松” 一些，毕竟是带了 “缓冲” 光环。

Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。

同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。

异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。

小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。
## 1.4 Goroutine
Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：
- 用户空间 避免了内核态和用户态的切换导致的成本
- 可以由语言和框架层进行调度
- 更小的栈空间允许创建大量的实例

可以看到第二条 用户空间线程的调度不是由操作系统来完成的，像在java 1.3中使用的greenthread的是由JVM统一调度的(后java已经改为内核线程)，还有在ruby中的fiber(半协程) 是需要在重新中自己进行调度的，而goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。
## 1.5 Goroutine调度器